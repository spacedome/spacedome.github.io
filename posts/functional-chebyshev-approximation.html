<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Functional Chebyshev Approximation</title>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Chebyshev">
    
    <meta name="author" content="Spacedome">
    
    
    <meta name="keywords" content="haskell, blog, chebyshev, algorithms, numerical">
    

    <meta property="og:site_name" content="Spacedome">
    <meta property="og:title" content="Functional Chebyshev Approximation">
    <meta property="og:url" content="https://spacedome.tv/posts/functional-chebyshev-approximation.html">
    <meta property="og:description" content="Chebyshev">
    
    
    <meta property="og:type" content="article">
    

    <link rel="shortcut icon" href="../favicon.ico">
    <link rel="canonical" href="https://spacedome.tv/posts/functional-chebyshev-approximation.html">

    <link rel="alternate" href="../atom.xml" title="Spacedome.tv" type="application/atom+xml">
    <link rel="alternate" href="../rss.xml" title="Spacedome.tv" type="application/rss+xml">

    <link rel="stylesheet" href="../css/code.css" />
    <link rel="stylesheet" href="../css/default.css" />

    
    <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/mml-chtml.min.js">
    </script>
    
  </head>
  <header>
      <a href="../">
          <img src="../images/spacedome.svg" alt="spacedome.tv" class="logo">
      </a>
  </header>
  <nav>
      <ul class="bar">
          <li><a href="../posts.html">Posts</a></li>
          <li><a href="../projects.html">Projects</a></li>
          <li><a href="../research.html">Research</a></li>
          <li><a href="../artwork.html">Artwork</a></li>
          <li><a href="https://github.com/spacedome">Github</a></li>
          <li><a href="../">About</a></li>
      </ul>
  </nav>
  <body>
    <main>
  <article>
    <header>
    <h1>Functional Chebyshev Approximation</h1>
    <p><i>2025-02-01 </i></p>
    <hr />
    </header>
    <section>
      <p>In a previous post I outlined the Fast Fourier Transform, which has many obvious uses regarding waves and periodic functions.
Personally, I have found more use in non-periodic function approximation, which we do largely with polynomials of various orthogonal bases.
In an incredible twist of fate, it turns out that the most ubiquitous polynomial basis, Chebyshev, is “Fourier in disguise” i.e. we can get one from the other under a special change of variables.
This means in some sense that in his study of the heat equation, Fourier solved not only all questions of periodic approximation, but that one hundred years later it would be realized that he had solved all non-periodic ones as well.
We can then put our DFT to good use solving any problem involving polynomial interpolation on an interval.</p>
<h1 id="overview-of-chebyshev">Overview of Chebyshev</h1>
<p>I won’t belabor the details of approximation theory here.
For references, I usually turn to Boyd’s <em>Spectral Methods</em> book (a strange and wonderful gem), or Trefethen’s <em>Approximation Theory and Approximation Practice</em>, but often the most useful is searching for relevant source code, as the theory is mainly relevant to justification and glosses over implementation.
The one aspect I will discuss is roughly how we translate from the periodic world of Fourier to the polynomial world of Chebyshev.</p>
<p>The first step of interpolation is choosing what points we wish to interpolate at.
For a periodic domain, we can show in various contexts that uniformly spaced points are optimal for various purposes.
Perhaps surprisingly, this is not true for an interval.
We will take the (non-periodic) interval <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mo>−</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(-1, 1)</annotation></semantics></math> as the domain throughout.
There are various methods for choosing a set of points, depending on what constraints you make of the basis functions, and in what sense you wish to optimize.
Here we begin to overlap with the classical study of quadratures, as approximating a function and approximating its integral go hand-in-hand, these are often referred to as quadrature points.
One such set of points are the Chebyshev nodes (there are actually two kinds of Chebyshev polynomials, and hence two sets of points, but we can ignore this here), which are the extremal points of the Chebyshev polynomials.
Looking at the picture of them, we see they correspond exactly to uniformly spaced points on the unit circle, projected onto the real line, giving us our first glimpse into how related this is to Fourier polynomials.
<img src="../images/chebyshev-nodes.svg" alt="Chebyshev Nodes" />
From a practical, numerical perspective, we see that this pushes the points out towards the endpoints non-linearly, directly counteracting Runge’s phenomenon and other issues we encounter when interpolating at uniformly spaced points.</p>
<h1 id="fft">FFT</h1>
<p>Chebyshev polynomials are a critical tool in approximation theory, even for studying existence and convergence of exact (theoretical) solutions.
One might think you could just use Taylor series for everything if you don’t care about numerical convergence speed, but this is not the case, and different approximations have vastly different convergence radii and geometry, and can help us understand qualitative aspects of convergence, which can have practical implications.
For the engineer, there is another reason Chebyshev approximation is so valuable, the ability to compute it with the Fast Fourier Transform.
The FFT having linearithmic/log-linear complexity is one of the miracles of signal processing, and we can then leverage seasoned numerical libraries and specialized hardware to get much of Chebyshev for free.
I will not go into how we show this, but the main thrust of it is that Chebyshev can be viewed as Fourier under a somewhat strange looking change of variables <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>n</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mo>cos</mo><mi>θ</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mo>cos</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mi>θ</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">T_n(\cos \theta) = \cos(n \theta)</annotation></semantics></math>.
Practically, we can compute the Chebyshev transform by sampling a function at the Chebyshev nodes, mentally thinking of how this projects back onto the top half of the unit circle, and we then reflect these points onto the bottom half of the unit circle, giving us twice as many points, which cover <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>2</mn><mi>π</mi><mo stretchy="true" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[0, 2\pi]</annotation></semantics></math> in this projection.
We can then apply the FFT (really we only need the Discrete Cosine Transform, half of the FFT) to get the coefficients of our polynomial basis, just like Fourier.
This reflection trick is strangely not often mentioned in the theory, but is critical if you want your implementation to work.
It works because of the symmetry of the cosine transform.</p>
<h1 id="approximating-a-function">Approximating a Function</h1>
<p>In approximating a function, the question is to what accuracy?
With Chebyshev, we can expect rapid convergence for anything remotely continuous, let alone differentiable.
For discontinuous functions, if the discontinuities are known, it is always preferable to approximate in sections, regardless of method, but Chebyshev can often perform in all but the most pathological scenarios, up to geometric (exponential) convergence for analytic functions.
Depending on application, we may be constrained as to the method of sampling, but in general we usually assume computationally cheap sampling across the entire domain, such as in an interactive environment like Mathematica.
With the efficiency of FFT, if there are no hard time constraints (i.e. real-time), we can even adaptively sample until sufficient convergence.</p>
<p>For the implementer, the main question becomes, in what representation do I store the approximation?
We can go back and forth between storing the samples, and storing the basis coefficients, and both have their advantages.
Using barycentric interpolation on the sample points, we can do quite a lot without using the coefficients at all, with no loss in accuracy.
Using coefficient representation, we can quickly, and with good numerical stability, compute the approximation at a point using the Clenshaw algorithm, a recursive method of polynomial evaluation.
In the sample representation we can perform arithmetic operations, such as adding two functions, trivially (though it may require re-sampling if they have different numbers of samples).
In the coefficient representation, we can differentiate the function by applying differentiation as a linear operator, allowing us to solve differential equations.</p>
<h1 id="differentiating-a-function--solving-an-ode">Differentiating a Function &amp; Solving an ODE</h1>
<p>It is well known that differentiation is a linear operator, the off-diagonal matrix for differentiating a polynomial in the standard basis is often shown in undergraduate linear algebra courses.
What is less well known is that when similar ideas are applied to a more numerically useful basis, we can solve huge classes of common ODEs with excellent convergence rates.
This gave rise to an entire field, typically called “Spectral Methods”, which solve a differential equation <em>globally</em> using some method of collocation, as opposed to Finite Element type methods, which solve <em>locally</em> using local basis functions, though these methods are often used in combination.
For Chebyshev methods, we can construct a differential operator directly as a matrix, and even square the matrix to get a second derivative, though there are some tricky questions of conditioning and boundary conditions.
Here is a plot showing a function, its derivatives, and the Chebyshev approximations.
<img src="../images/chebyshev-deriv.svg" alt="Chebyshev Derivatives" />
If one is familiar with ODEs, it is not hard to see how we could use this to solve differential equations, given that we figure out how to represent boundary conditions and initial values.
Here is an example of how accurately we can solve an ODE defining a trigonometric function with only seven sample points (sixth-order Chebyshev approximation).
With any more points we would no longer be able to visually distinguish them on the plot.
<img src="../images/chebyshev-ode.svg" alt="Chebyshev Derivatives" /></p>
<h1 id="closing-remarks">Closing Remarks</h1>
<p>A common refrain of numerical libraries is that, if you can understand the theory, you can often implement quite advanced algorithms in just a few dozen lines of code, even without the typical scientific computing primitives.
The great difficulty of the library creator and maintainer is the thousands and thousands of lines of code that actually make it useful, which often requires a great amount of thought and many iterations to get the core design correct.
As someone writing our own implementations of algorithms, this means we get a quick thrill of rapidly seeing a proof of concept to fruition, but the bitterness of knowing how far we are from something genuinely useful, unless we wish to spend thankless months building and maintaining “the boring parts.”</p>
<p>For Chebyshev libraries, I recommend using ApproxFun.jl in Julia or Chebfun in Matlab, depending on your preference.</p>
<p>I have implemented enough in Haskell to solve some simple ODEs, and decided to stop before going down the rabbit hole of features.
The main choices to make in going further are, which representation do you use (sample points or coefficients), and if the target usage warrants highly dynamic behavior for interactive applications, or a more strictly defined numerical building block for something such as real time use.
In particular with Haskell one could use the type system to ensure semantic correctness of your library primitives, something I neglected.
For posterity, my implementation is below.</p>
<h1 id="haskell">Haskell</h1>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Chebyshev</span> <span class="kw">where</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Numeric.GSL.Fourier</span> (fft, ifft)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Numeric.LinearAlgebra.Data</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Numeric.LinearAlgebra</span> ((#&gt;), (&lt;\&gt;))</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Numeric.Natural</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Vector.Generic</span> <span class="kw">as</span> <span class="dt">V</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="co">{- Cheb - representation of our Chebyshev approximation.</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="co"> We store this using a sample at the extremal nodes, and not coefficients, following Chebfun.</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="co"> This has numerous benefits, and we can go between representations as needed -}</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Cheb</span> <span class="ot">=</span> <span class="dt">Cheb</span> {<span class="ot">getNodes ::</span> <span class="dt">Vector</span> <span class="dt">R</span>}</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">ChebNodes</span> <span class="ot">=</span> <span class="dt">Vector</span> <span class="dt">R</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">ChebCoefs</span> <span class="ot">=</span> <span class="dt">Vector</span> <span class="dt">R</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Function to sample from in computing a Cheb</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Function</span> <span class="ot">=</span> <span class="dt">Function</span> {<span class="ot">evalF ::</span> <span class="dt">R</span> <span class="ot">-&gt;</span> <span class="dt">R</span>}</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Compute the Nth extremal nodes, i.e. the interpolation points for our Cheb</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="ot">extremalChebNodes ::</span> <span class="dt">Natural</span> <span class="ot">-&gt;</span> <span class="dt">ChebNodes</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>extremalChebNodes n <span class="ot">=</span> build (<span class="fu">fromIntegral</span> n <span class="op">+</span> <span class="dv">1</span>) (\x <span class="ot">-&gt;</span> <span class="fu">cos</span> (<span class="fu">pi</span> <span class="op">*</span> x <span class="op">/</span> <span class="fu">fromIntegral</span> n))</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a><span class="co">-- </span><span class="al">TODO</span><span class="co">: make size dynamic based on convergence</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a><span class="co">{- | Compute a Cheb representation of a Function. -}</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a><span class="ot">computeCheb ::</span> <span class="dt">Function</span> <span class="ot">-&gt;</span> <span class="dt">Natural</span> <span class="ot">-&gt;</span> <span class="dt">Cheb</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>computeCheb f n <span class="ot">=</span> <span class="dt">Cheb</span> (cmap (evalF f) (extremalChebNodes n))</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a><span class="co">{- | Get the Chebyshev coefficients of a Cheb</span></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a><span class="co">This uses the FFT and is sometimes called the &quot;Discrete Chebyshev Transform&quot;</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a><span class="co">&gt;&gt; getChebCoef (computeCheb (Function (**4)) 4)</span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a><span class="co">[0.575, 0.0, 0.5, 0.0, 0.125]</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a><span class="co">-}</span></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a><span class="ot">getChebCoef ::</span> <span class="dt">Cheb</span> <span class="ot">-&gt;</span> <span class="dt">ChebCoefs</span></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>getChebCoef (<span class="dt">Cheb</span> nodes) <span class="ot">=</span> filtered</span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- None of the literature seems to mention this, but computing the coefficients</span></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- from the extremal nodes doesn't seem to work without this reflection trick</span></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> reflected <span class="ot">=</span> nodes <span class="op">&lt;&gt;</span> (V.reverse <span class="op">.</span> V.tail <span class="op">.</span> V.init) nodes</span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>        frequency <span class="ot">=</span> V.take (V.length nodes) ((cmap realPart <span class="op">.</span> fft <span class="op">.</span> complex) reflected)</span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>        <span class="co">-- this FFT library does not normalize output, so we divide by N</span></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>        scaled    <span class="ot">=</span> cmap (<span class="op">/</span> <span class="fu">fromIntegral</span> (V.length frequency <span class="op">-</span> <span class="dv">1</span>)) frequency</span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>        <span class="co">-- outermost points must be scaled by an additional factor of two</span></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>        scaled2   <span class="ot">=</span> scaled <span class="op">V.//</span> [(<span class="dv">0</span>, <span class="fl">0.5</span> <span class="op">*</span> V.head scaled), (V.length scaled <span class="op">-</span> <span class="dv">1</span>, <span class="fl">0.5</span> <span class="op">*</span> V.last scaled)]</span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>        <span class="co">-- might as well get rid of things near numerical zero, should improve stability</span></span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>        filtered  <span class="ot">=</span> cmap (\x <span class="ot">-&gt;</span> <span class="kw">if</span> <span class="fu">abs</span> x <span class="op">&gt;</span> <span class="fl">1e-14</span> <span class="kw">then</span> x <span class="kw">else</span> <span class="fl">0.0</span> ) scaled2</span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a><span class="co">{- | Go from coefficients back to extremal node samples</span></span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a><span class="co">&gt;&gt; inverseChebCoef (getChebCoef (computeCheb (Function (**4)) 4))</span></span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a><span class="co">[1.0, 0.5, 0.0, 0.5, 1.0]</span></span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a><span class="co">-}</span></span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a><span class="ot">inverseChebCoef ::</span> <span class="dt">ChebCoefs</span> <span class="ot">-&gt;</span> <span class="dt">Cheb</span></span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a>inverseChebCoef coef <span class="ot">=</span> <span class="dt">Cheb</span> frequency</span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> rescaled  <span class="ot">=</span> coef <span class="op">V.//</span> [(<span class="dv">0</span>, <span class="fl">2.0</span> <span class="op">*</span> V.head coef), (V.length coef <span class="op">-</span> <span class="dv">1</span>, <span class="fl">2.0</span> <span class="op">*</span> V.last coef)]</span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a>        <span class="co">-- undo the scaling steps</span></span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a>        rescaled2 <span class="ot">=</span> cmap (<span class="op">*</span> <span class="fu">fromIntegral</span> (V.length rescaled <span class="op">-</span> <span class="dv">1</span>)) rescaled</span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a>        <span class="co">-- do the reflection trick again (this works in both directions)</span></span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a>        reflected <span class="ot">=</span> rescaled2 <span class="op">&lt;&gt;</span> (V.reverse <span class="op">.</span> V.tail <span class="op">.</span> V.init) rescaled2</span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a>        <span class="co">-- ifft and you're back</span></span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a>        frequency <span class="ot">=</span> V.take (V.length coef) ((cmap realPart <span class="op">.</span> ifft <span class="op">.</span> complex) reflected)</span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Compute the first order Chebyshev differentiation matrix</span></span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true" tabindex="-1"></a><span class="ot">chebDf ::</span> <span class="dt">Natural</span> <span class="ot">-&gt;</span> <span class="dt">Matrix</span> <span class="dt">R</span></span>
<span id="cb1-65"><a href="#cb1-65" aria-hidden="true" tabindex="-1"></a>chebDf dim <span class="ot">=</span> build (m, m) f</span>
<span id="cb1-66"><a href="#cb1-66" aria-hidden="true" tabindex="-1"></a> <span class="kw">where</span></span>
<span id="cb1-67"><a href="#cb1-67" aria-hidden="true" tabindex="-1"></a>  m <span class="ot">=</span> <span class="fu">fromIntegral</span> dim <span class="op">+</span> <span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Int</span></span>
<span id="cb1-68"><a href="#cb1-68" aria-hidden="true" tabindex="-1"></a>  n <span class="ot">=</span> <span class="fu">fromIntegral</span><span class="ot"> dim ::</span> <span class="dt">R</span></span>
<span id="cb1-69"><a href="#cb1-69" aria-hidden="true" tabindex="-1"></a>  x <span class="ot">=</span> extremalChebNodes dim</span>
<span id="cb1-70"><a href="#cb1-70" aria-hidden="true" tabindex="-1"></a><span class="ot">  f ::</span> <span class="dt">R</span> <span class="ot">-&gt;</span> <span class="dt">R</span> <span class="ot">-&gt;</span> <span class="dt">R</span></span>
<span id="cb1-71"><a href="#cb1-71" aria-hidden="true" tabindex="-1"></a>  f i j</span>
<span id="cb1-72"><a href="#cb1-72" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> (i, j) <span class="op">==</span> (<span class="dv">0</span>, <span class="dv">0</span>) <span class="ot">=</span> (<span class="dv">2</span> <span class="op">*</span> n <span class="op">**</span> <span class="dv">2</span> <span class="op">+</span> <span class="dv">1</span>) <span class="op">/</span> <span class="dv">6</span></span>
<span id="cb1-73"><a href="#cb1-73" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> (i, j) <span class="op">==</span> (n, n) <span class="ot">=</span> <span class="op">-</span>(<span class="dv">2</span> <span class="op">*</span> n <span class="op">**</span> <span class="dv">2</span> <span class="op">+</span> <span class="dv">1</span>) <span class="op">/</span> <span class="dv">6</span></span>
<span id="cb1-74"><a href="#cb1-74" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> i <span class="op">==</span> j <span class="ot">=</span> <span class="op">-</span>xi <span class="op">/</span> (<span class="dv">2</span> <span class="op">*</span> (<span class="dv">1</span> <span class="op">-</span> xi <span class="op">**</span> <span class="dv">2</span>))</span>
<span id="cb1-75"><a href="#cb1-75" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> ((<span class="op">-</span><span class="dv">1</span>) <span class="op">**</span> (i <span class="op">+</span> j)) <span class="op">*</span> c i <span class="op">/</span> (c j <span class="op">*</span> (xi <span class="op">-</span> xj))</span>
<span id="cb1-76"><a href="#cb1-76" aria-hidden="true" tabindex="-1"></a>     <span class="kw">where</span></span>
<span id="cb1-77"><a href="#cb1-77" aria-hidden="true" tabindex="-1"></a>      <span class="co">-- hmatrix `build` only takes R -&gt; R -&gt; R so we have to round...</span></span>
<span id="cb1-78"><a href="#cb1-78" aria-hidden="true" tabindex="-1"></a>      xi <span class="ot">=</span> x <span class="op">!</span> <span class="fu">round</span> i</span>
<span id="cb1-79"><a href="#cb1-79" aria-hidden="true" tabindex="-1"></a>      xj <span class="ot">=</span> x <span class="op">!</span> <span class="fu">round</span> j</span>
<span id="cb1-80"><a href="#cb1-80" aria-hidden="true" tabindex="-1"></a>      c z</span>
<span id="cb1-81"><a href="#cb1-81" aria-hidden="true" tabindex="-1"></a>        <span class="op">|</span> z <span class="op">==</span> <span class="dv">0</span> <span class="ot">=</span> <span class="dv">2</span></span>
<span id="cb1-82"><a href="#cb1-82" aria-hidden="true" tabindex="-1"></a>        <span class="op">|</span> z <span class="op">==</span> n <span class="ot">=</span> <span class="dv">2</span></span>
<span id="cb1-83"><a href="#cb1-83" aria-hidden="true" tabindex="-1"></a>        <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb1-84"><a href="#cb1-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-85"><a href="#cb1-85" aria-hidden="true" tabindex="-1"></a><span class="co">-- </span><span class="al">NOTE</span><span class="co">: This is just a convenience atm, should add better</span></span>
<span id="cb1-86"><a href="#cb1-86" aria-hidden="true" tabindex="-1"></a><span class="co">-- abstraction for constructing the differential operators</span></span>
<span id="cb1-87"><a href="#cb1-87" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Compute the second order Chebyshev differentiation matrix</span></span>
<span id="cb1-88"><a href="#cb1-88" aria-hidden="true" tabindex="-1"></a><span class="ot">chebDf2 ::</span> <span class="dt">Natural</span> <span class="ot">-&gt;</span> <span class="dt">Matrix</span> <span class="dt">R</span></span>
<span id="cb1-89"><a href="#cb1-89" aria-hidden="true" tabindex="-1"></a>chebDf2 dim <span class="ot">=</span> x <span class="op">&lt;&gt;</span> x</span>
<span id="cb1-90"><a href="#cb1-90" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> x <span class="ot">=</span> chebDf dim</span>
<span id="cb1-91"><a href="#cb1-91" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-92"><a href="#cb1-92" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Differentiate a Cheb</span></span>
<span id="cb1-93"><a href="#cb1-93" aria-hidden="true" tabindex="-1"></a><span class="ot">diffCheb ::</span> <span class="dt">Cheb</span> <span class="ot">-&gt;</span> <span class="dt">Cheb</span></span>
<span id="cb1-94"><a href="#cb1-94" aria-hidden="true" tabindex="-1"></a>diffCheb (<span class="dt">Cheb</span> c) <span class="ot">=</span> <span class="dt">Cheb</span> (d <span class="op">#&gt;</span> c)</span>
<span id="cb1-95"><a href="#cb1-95" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> n <span class="ot">=</span> V.length c <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb1-96"><a href="#cb1-96" aria-hidden="true" tabindex="-1"></a>        d <span class="ot">=</span> chebDf (<span class="fu">fromIntegral</span> n)</span>
<span id="cb1-97"><a href="#cb1-97" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-98"><a href="#cb1-98" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Boundary condition types</span></span>
<span id="cb1-99"><a href="#cb1-99" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Neumann and Mixed not currently implemented</span></span>
<span id="cb1-100"><a href="#cb1-100" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">BC</span> <span class="ot">=</span> <span class="dt">DirichletBC</span> <span class="op">|</span> <span class="dt">NeumannBC</span> <span class="op">|</span> <span class="dt">MixedBC</span> <span class="op">|</span> <span class="dt">UnconstrainedBC</span></span>
<span id="cb1-101"><a href="#cb1-101" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Represent a Differential Linear Operator</span></span>
<span id="cb1-102"><a href="#cb1-102" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">DL</span> <span class="ot">=</span> <span class="dt">DL</span> (<span class="dt">Matrix</span> <span class="dt">R</span>) <span class="dt">BC</span> <span class="dt">BC</span></span>
<span id="cb1-103"><a href="#cb1-103" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-104"><a href="#cb1-104" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-105"><a href="#cb1-105" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Solve L u = f by computing u = L \ f</span></span>
<span id="cb1-106"><a href="#cb1-106" aria-hidden="true" tabindex="-1"></a>(<span class="op">&lt;</span>\\<span class="op">&gt;</span>)<span class="ot"> ::</span> <span class="dt">DL</span> <span class="ot">-&gt;</span> <span class="dt">Function</span> <span class="ot">-&gt;</span> <span class="dt">Cheb</span></span>
<span id="cb1-107"><a href="#cb1-107" aria-hidden="true" tabindex="-1"></a>(<span class="op">&lt;</span>\\<span class="op">&gt;</span>) (<span class="dt">DL</span> df lbc rbc) f <span class="ot">=</span> <span class="dt">Cheb</span> (dfbc <span class="op">&lt;</span>\<span class="op">&gt;</span> getNodes chebf)</span>
<span id="cb1-108"><a href="#cb1-108" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> n <span class="ot">=</span> <span class="fu">fromIntegral</span> (rows df) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb1-109"><a href="#cb1-109" aria-hidden="true" tabindex="-1"></a>        chebf <span class="ot">=</span> computeCheb f n</span>
<span id="cb1-110"><a href="#cb1-110" aria-hidden="true" tabindex="-1"></a>        ldirichlet a xs <span class="ot">=</span> vector (a<span class="op">:</span> <span class="fu">replicate</span> (<span class="fu">fromIntegral</span> n) <span class="fl">0.0</span>) <span class="op">:</span> <span class="fu">tail</span> xs</span>
<span id="cb1-111"><a href="#cb1-111" aria-hidden="true" tabindex="-1"></a>        rdirichlet a xs <span class="ot">=</span> <span class="fu">init</span> xs <span class="op">++</span> [vector (<span class="fu">replicate</span> (<span class="fu">fromIntegral</span> n) <span class="fl">0.0</span> <span class="op">++</span> [a])]</span>
<span id="cb1-112"><a href="#cb1-112" aria-hidden="true" tabindex="-1"></a>        dfrows <span class="ot">=</span> toRows df</span>
<span id="cb1-113"><a href="#cb1-113" aria-hidden="true" tabindex="-1"></a>        rows' <span class="ot">=</span> <span class="kw">case</span> lbc <span class="kw">of</span></span>
<span id="cb1-114"><a href="#cb1-114" aria-hidden="true" tabindex="-1"></a>          <span class="dt">DirichletBC</span>     <span class="ot">-&gt;</span> ldirichlet <span class="dv">1</span> dfrows</span>
<span id="cb1-115"><a href="#cb1-115" aria-hidden="true" tabindex="-1"></a>          <span class="dt">NeumannBC</span>       <span class="ot">-&gt;</span> <span class="fu">undefined</span></span>
<span id="cb1-116"><a href="#cb1-116" aria-hidden="true" tabindex="-1"></a>          <span class="dt">MixedBC</span>         <span class="ot">-&gt;</span> <span class="fu">undefined</span></span>
<span id="cb1-117"><a href="#cb1-117" aria-hidden="true" tabindex="-1"></a>          <span class="dt">UnconstrainedBC</span> <span class="ot">-&gt;</span> dfrows</span>
<span id="cb1-118"><a href="#cb1-118" aria-hidden="true" tabindex="-1"></a>        row'' <span class="ot">=</span> <span class="kw">case</span> rbc <span class="kw">of</span> </span>
<span id="cb1-119"><a href="#cb1-119" aria-hidden="true" tabindex="-1"></a>          <span class="dt">DirichletBC</span>     <span class="ot">-&gt;</span> rdirichlet <span class="dv">1</span> rows'</span>
<span id="cb1-120"><a href="#cb1-120" aria-hidden="true" tabindex="-1"></a>          <span class="dt">NeumannBC</span>       <span class="ot">-&gt;</span> <span class="fu">undefined</span></span>
<span id="cb1-121"><a href="#cb1-121" aria-hidden="true" tabindex="-1"></a>          <span class="dt">MixedBC</span>         <span class="ot">-&gt;</span> <span class="fu">undefined</span></span>
<span id="cb1-122"><a href="#cb1-122" aria-hidden="true" tabindex="-1"></a>          <span class="dt">UnconstrainedBC</span> <span class="ot">-&gt;</span> rows'</span>
<span id="cb1-123"><a href="#cb1-123" aria-hidden="true" tabindex="-1"></a>        dfbc <span class="ot">=</span> fromRows row''</span>
<span id="cb1-124"><a href="#cb1-124" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-125"><a href="#cb1-125" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-126"><a href="#cb1-126" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">C</span> <span class="ot">=</span> <span class="dt">C</span> <span class="ot">{-# UNPACK #-}</span> <span class="op">!</span><span class="dt">R</span> <span class="ot">{-# UNPACK #-}</span> <span class="op">!</span><span class="dt">R</span></span>
<span id="cb1-127"><a href="#cb1-127" aria-hidden="true" tabindex="-1"></a><span class="co">{- | Evaluate a Chebyshev polynomial of the first kind. </span></span>
<span id="cb1-128"><a href="#cb1-128" aria-hidden="true" tabindex="-1"></a><span class="co">Uses Clenshaw's algorithm.</span></span>
<span id="cb1-129"><a href="#cb1-129" aria-hidden="true" tabindex="-1"></a><span class="co">Implementation taken from `math-functions` package (BSD3) -}</span></span>
<span id="cb1-130"><a href="#cb1-130" aria-hidden="true" tabindex="-1"></a><span class="ot">clenshaw ::</span> <span class="dt">ChebCoefs</span>    <span class="co">-- ^ Coefficients of each polynomial term, in increasing order.</span></span>
<span id="cb1-131"><a href="#cb1-131" aria-hidden="true" tabindex="-1"></a>          <span class="ot">-&gt;</span> <span class="dt">R</span>       <span class="co">-- ^ point to evalute at</span></span>
<span id="cb1-132"><a href="#cb1-132" aria-hidden="true" tabindex="-1"></a>          <span class="ot">-&gt;</span> <span class="dt">R</span></span>
<span id="cb1-133"><a href="#cb1-133" aria-hidden="true" tabindex="-1"></a>clenshaw a x <span class="ot">=</span> fini <span class="op">.</span> V.foldr' stpp (<span class="dt">C</span> <span class="dv">0</span> <span class="dv">0</span>) <span class="op">.</span> V.tail <span class="op">$</span> a</span>
<span id="cb1-134"><a href="#cb1-134" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> stpp k (<span class="dt">C</span> b0 b1) <span class="ot">=</span> <span class="dt">C</span> (k <span class="op">+</span> x2 <span class="op">*</span> b0 <span class="op">-</span> b1) b0</span>
<span id="cb1-135"><a href="#cb1-135" aria-hidden="true" tabindex="-1"></a>          fini   (<span class="dt">C</span> b0 b1) <span class="ot">=</span> V.head a <span class="op">+</span> x <span class="op">*</span> b0 <span class="op">-</span> b1</span>
<span id="cb1-136"><a href="#cb1-136" aria-hidden="true" tabindex="-1"></a>          x2               <span class="ot">=</span> x <span class="op">*</span> <span class="dv">2</span></span>
<span id="cb1-137"><a href="#cb1-137" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# INLINE clenshaw #-}</span></span></code></pre></div>
    </section>
  </article>
</main>

    <script defer src="../js/script.js"></script>
  </body>
  <footer>
  <div>
      <p>
      Generated with Hakyll &copy 2024
      </p>
  </div>
  </footer>
</html>
